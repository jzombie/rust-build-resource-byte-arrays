use bytes::Bytes;
use std::env;
use std::fs::{self, File};
use std::io::{self, BufRead, BufReader, Write};
use std::path::{Path, PathBuf};

/// Writes byte arrays to a Rust file as `pub static` constants and saves the
/// byte contents to individual `.bin` files.
///
/// # Arguments
/// * `output_rust_path` - The path where the main generated Rust file will be written.
/// * `byte_arrays` - A list of tuples (name, content) where:
///     - `name` is the name of the `pub static` variable.
///     - `content` is a `Bytes` object containing the byte data.
/// * `feature_flag` - An optional feature flag for conditional compilation.
///
/// # Example
/// ```
/// use build_resource_byte_arrays::write_byte_arrays;
/// use bytes::Bytes;
///
/// write_byte_arrays(
///     "src/dynamic_resources.rs",
///     vec![("ARRAY1", Bytes::from(vec![1, 2, 3]))],
///     Some("build_resource_byte_arrays".to_string()),
/// ).unwrap();
/// ```
pub fn write_byte_arrays<P: AsRef<Path>>(
    output_rust_path: P,
    byte_arrays: Vec<(&str, Bytes)>,
    feature_flag: Option<String>,
) -> io::Result<()> {
    // Ensure OUT_DIR is set (required for build.rs)
    let out_dir = env::var("OUT_DIR").map_err(|_| {
        io::Error::new(
            io::ErrorKind::Other,
            "This function must be called from within build.rs (OUT_DIR is not set).",
        )
    })?;
    let output_bin_dir = PathBuf::from(&out_dir).join("bin");

    // Resolve the feature flag
    let expanded_feature_flag =
        feature_flag.unwrap_or_else(|| "build_resource_byte_arrays".to_string());

    // Ensure the output binary directory exists
    fs::create_dir_all(&output_bin_dir)?;

    // Create or truncate the Rust file
    let rust_file_path = output_rust_path.as_ref();
    let rust_file_dir = rust_file_path
        .parent()
        .ok_or_else(|| io::Error::new(io::ErrorKind::Other, "Invalid Rust file path"))?;

    let mut rust_file = File::create(rust_file_path)?;

    // Write a header to the main Rust file
    writeln!(
      rust_file,
      "// Automatically generated file. Do not edit.\n// Generated by build-resource-byte-arrays crate.\n"
  )?;

    // Create the secondary file path
    let secondary_file_path = rust_file_dir.join("dynamic_resources_generated.rs");
    let mut secondary_file = File::create(&secondary_file_path)?;

    // Write header to the secondary file
    writeln!(
      secondary_file,
      "// Automatically generated file. Do not edit.\n// This file dynamically includes resources using OUT_DIR.\n"
  )?;

    for (name, content) in &byte_arrays {
        // Write the `.bin` file
        let bin_file_path = output_bin_dir.join(format!("{name}.bin"));
        let mut bin_file = File::create(&bin_file_path)?;
        bin_file.write_all(&content)?;

        // Write to the secondary file (directly references OUT_DIR)
        writeln!(secondary_file, "#[allow(clippy::env_in_macro)]")?;
        writeln!(
          secondary_file,
          "pub static {name}: &[u8] = include_bytes!(concat!(env!(\"OUT_DIR\"), \"/bin/{name}.bin\"));"
      )?;
    }

    // Write conditional inclusion in the main Rust file
    writeln!(
        rust_file,
        "#[cfg(feature = \"{}\")]\ninclude!(\"dynamic_resources_generated.rs\");",
        expanded_feature_flag
    )?;

    // Write fallback in the main Rust file
    writeln!(
        rust_file,
        "#[cfg(not(feature = \"{}\"))]",
        expanded_feature_flag
    )?;
    writeln!(rust_file, "mod dynamic_resources_fallback {{")?;
    for (name, _) in &byte_arrays {
        writeln!(rust_file, "    pub static {name}: &[u8] = &[];")?;
    }
    writeln!(rust_file, "}}")?;

    writeln!(
        rust_file,
        "#[cfg(not(feature = \"{}\"))]\npub use dynamic_resources_fallback::*;",
        expanded_feature_flag
    )?;

    Ok(())
}
