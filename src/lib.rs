use bytes::Bytes;
use std::env;
use std::fs::{self, File};
use std::io::{self, Write};
use std::path::Path;

/// Writes byte arrays to a Rust file as `pub static` constants and saves the
/// byte contents to individual `.bin` files.
///
/// # Arguments
/// * `output_rust_path` - The path where the generated Rust file will be written.
/// * `byte_arrays` - A list of tuples (name, content) where:
///     - `name` is the name of the `pub static` variable.
///     - `content` is a `Bytes` object containing the byte data.
///
/// # Example
/// ```
/// use build_resource_byte_arrays::write_byte_arrays;
/// use bytes::Bytes;
///
/// write_byte_arrays(
///     "output.rs",
///     vec![("ARRAY1", Bytes::from(vec![1, 2, 3]))],
///     Some("build_resource_byte_arrays".to_string()),
/// ).unwrap();
/// ```
pub fn write_byte_arrays<P: AsRef<Path>>(
    output_rust_path: P,
    byte_arrays: Vec<(&str, Bytes)>,
    feature_flag: Option<String>,
) -> io::Result<()> {
    // Ensure the function is running in the context of `build.rs`
    let out_dir = env::var("OUT_DIR").map_err(|_| {
        io::Error::new(
            io::ErrorKind::Other,
            "This function must be called from within build.rs (OUT_DIR is not set).",
        )
    })?;

    // Resolve the feature flag
    let expanded_feature_flag =
        feature_flag.unwrap_or_else(|| "build_resource_byte_arrays".to_string());

    // Get the Rust file path and OUT_DIR for binaries
    let rust_file_path = output_rust_path.as_ref();
    let output_bin_dir = Path::new(&out_dir).join("bin");

    // Ensure the output binary directory exists
    fs::create_dir_all(&output_bin_dir)?;

    // Create or truncate the Rust file
    let mut rust_file = File::create(rust_file_path)?;

    // Write a header to the Rust file
    writeln!(
        rust_file,
        "// Automatically generated file. Do not edit.\n// Generated by build-resource-byte-arrays crate.\n"
    )?;

    for (name, content) in byte_arrays {
        // Write the `.bin` file
        let bin_file_path = output_bin_dir.join(format!("{name}.bin"));
        let mut bin_file = File::create(&bin_file_path)?;
        bin_file.write_all(&content)?;

        // Write the `#[cfg(feature)]` block
        writeln!(rust_file, "#[cfg(feature = \"{}\")]", expanded_feature_flag)?;
        writeln!(
            rust_file,
            "pub static {name}: &[u8] = include_bytes!(concat!(env!(\"OUT_DIR\"),\"/bin/{name}.bin\"));",
        )?;
        writeln!(rust_file, "")?;

        // Write the `#[cfg(not(feature))]` block
        writeln!(
            rust_file,
            "#[cfg(not(feature = \"{}\"))]",
            expanded_feature_flag
        )?;
        writeln!(rust_file, "pub static {name}: &[u8] = &[];")?;
        writeln!(rust_file, "")?;

        // Write a warning using the `ctor` crate for runtime notification
        writeln!(
            rust_file,
            "#[cfg(not(feature = \"{}\"))]",
            expanded_feature_flag
        )?;
        writeln!(rust_file, "#[ctor::ctor]")?;
        writeln!(rust_file, "fn warn_{name}_empty() {{",)?;
        writeln!(
            rust_file,
            "    eprintln!(\"Warning: `{name}` is empty because the `{} ` feature is not enabled.\");",
            expanded_feature_flag
        )?;
        writeln!(rust_file, "}}")?;
        writeln!(rust_file, "")?;
    }

    Ok(())
}
