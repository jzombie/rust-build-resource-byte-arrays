use bytes::Bytes;
use std::env;
use std::fs::{self, File};
use std::io::{self, BufRead, BufReader, Write};
use std::path::{Path, PathBuf};

/// Writes byte arrays to a Rust file as `pub static` constants and saves the
/// byte contents to individual `.bin` files.
///
/// # Arguments
/// * `output_rust_path` - The path where the generated Rust file will be written.
/// * `byte_arrays` - A list of tuples (name, content) where:
///     - `name` is the name of the `pub static` variable.
///     - `content` is a `Bytes` object containing the byte data.
/// * `feature_flag` - An optional feature flag for conditional compilation.
///
/// # Example
/// ```
/// use build_resource_byte_arrays::write_byte_arrays;
/// use bytes::Bytes;
///
/// write_byte_arrays(
///     "src/dynamic_resources.rs",
///     vec![("ARRAY1", Bytes::from(vec![1, 2, 3]))],
///     Some("build_resource_byte_arrays".to_string()),
/// ).unwrap();
/// ```
pub fn write_byte_arrays<P: AsRef<Path>>(
    output_rust_path: P,
    byte_arrays: Vec<(&str, Bytes)>,
    feature_flag: Option<String>,
) -> io::Result<()> {
    // Ensure OUT_DIR is set (required for build.rs)
    let out_dir = env::var("OUT_DIR").map_err(|_| {
        io::Error::new(
            io::ErrorKind::Other,
            "This function must be called from within build.rs (OUT_DIR is not set).",
        )
    })?;
    let output_bin_dir = PathBuf::from(&out_dir).join("bin");

    // Resolve the feature flag
    let expanded_feature_flag =
        feature_flag.unwrap_or_else(|| "build_resource_byte_arrays".to_string());

    // Ensure the output binary directory exists
    fs::create_dir_all(&output_bin_dir)?;

    // Create or truncate the Rust file
    let rust_file_path = output_rust_path.as_ref();
    let rust_file_dir = rust_file_path
        .parent()
        .ok_or_else(|| io::Error::new(io::ErrorKind::Other, "Invalid Rust file path"))?;

    let mut rust_file = File::create(rust_file_path)?;

    // Write a header to the Rust file
    writeln!(
        rust_file,
        "// Automatically generated file. Do not edit.\n// Generated by build-resource-byte-arrays crate.\n"
    )?;

    for (name, content) in byte_arrays {
        // Write the `.bin` file
        let bin_file_path = output_bin_dir.join(format!("{name}.bin"));
        let mut bin_file = File::create(&bin_file_path)?;
        bin_file.write_all(&content)?;

        // Compute the relative path from the Rust file to the `.bin` file
        let bin_file_relative_path = compute_relative_path(&bin_file_path, rust_file_dir)?;

        // Write the `#[cfg(feature)]` block
        writeln!(rust_file, "#[cfg(feature = \"{}\")]", expanded_feature_flag)?;
        writeln!(rust_file, "#[doc = \"This file path is automatically generated during compilation and points to a build-time resource (generated pre-compilation by `build.rs`).\"]")?;
        writeln!(rust_file, "#[doc = \"It reflects the state of the resource at the time of compilation, which may not match the source code or file system in subsequent builds.\"]")?;
        writeln!(
            rust_file,
            "pub static {name}: &[u8] = include_bytes!(\"{}\");",
            bin_file_relative_path
        )?;
        writeln!(rust_file)?;

        // Write the `#[cfg(not(feature))]` block
        writeln!(
            rust_file,
            "#[cfg(not(feature = \"{}\"))]",
            expanded_feature_flag
        )?;
        writeln!(rust_file, "pub static {name}: &[u8] = &[];")?;
        writeln!(rust_file)?;

        // Write a warning using the `ctor` crate for runtime notification
        writeln!(
            rust_file,
            "#[cfg(not(feature = \"{}\"))]",
            expanded_feature_flag
        )?;
        writeln!(rust_file, "#[ctor::ctor]")?;
        writeln!(rust_file, "fn warn_{name}_empty() {{",)?;
        writeln!(
            rust_file,
            "    eprintln!(\"Warning: `{name}` is empty because the `{} ` feature is not enabled.\");",
            expanded_feature_flag
        )?;
        writeln!(rust_file, "}}")?;
        writeln!(rust_file)?;
    }

    Ok(())
}

/// Computes the relative path from `base` to `target`.
///
/// This function calculates the relative path from the directory containing
/// `output_rust_path` to the file in `OUT_DIR`.
/// Computes the relative path from `base` to `target`.
///
/// This function calculates the relative path manually without relying
/// on any external dependencies.
///
/// # Arguments
/// * `target` - The full path to the target file.
/// * `base` - The directory to which the relative path will be computed.
///
/// # Returns
/// A relative path from `base` to `target` as a `String`.
fn compute_relative_path(target: &Path, base: &Path) -> io::Result<String> {
    let target = target.canonicalize()?;
    let base = base.canonicalize()?;

    // If the `target` is already under `base`, return the relative path
    if let Ok(rel_path) = target.strip_prefix(&base) {
        return rel_path.to_str().map(|s| s.to_string()).ok_or_else(|| {
            io::Error::new(io::ErrorKind::Other, "Failed to convert path to string")
        });
    }

    // Break down `base` and `target` into their components
    let target_components: Vec<_> = target.components().collect();
    let base_components: Vec<_> = base.components().collect();

    // Find the common prefix
    let common_prefix_len = target_components
        .iter()
        .zip(base_components.iter())
        .take_while(|(t, b)| t == b)
        .count();

    // Calculate how many `..` to go back from `base`
    let mut relative_path = PathBuf::new();
    for _ in base_components.iter().skip(common_prefix_len) {
        relative_path.push("..");
    }

    // Append the remaining components of `target`
    for comp in target_components.iter().skip(common_prefix_len) {
        relative_path.push(comp.as_os_str());
    }

    // Convert to a string and return
    relative_path
        .to_str()
        .map(|s| s.to_string())
        .ok_or_else(|| io::Error::new(io::ErrorKind::Other, "Failed to convert path to string"))
}

/// Clears all `pub static` byte arrays in the specified Rust file.
///
/// # Arguments
/// * `output_path` - The path to the generated Rust file.
///
/// # Example
/// ```
/// use build_resource_byte_arrays::clear_byte_arrays;
/// clear_byte_arrays("output.rs")?;
/// ```
pub fn clear_byte_arrays(output_path: &str) -> io::Result<()> {
    let path = Path::new(output_path);
    // Read the file and collect the lines
    let file = File::open(path)?;
    let reader = BufReader::new(file);
    let mut lines: Vec<String> = reader.lines().collect::<Result<_, _>>()?;
    // Look for `pub static` definitions and replace their contents with `&[]`
    for line in lines.iter_mut() {
        if line.trim_start().starts_with("pub static") {
            if let Some(eq_pos) = line.find('=') {
                // Replace everything after the '=' with `&[];`
                *line = format!("{} = &[];", &line[..eq_pos].trim_end());
            }
        }
    }
    // Write the updated lines back to the file
    let mut file = File::create(path)?;
    for line in lines {
        writeln!(file, "{}", line)?;
    }
    Ok(())
}
